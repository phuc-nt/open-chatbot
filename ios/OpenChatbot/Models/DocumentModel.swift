import Foundation
import CoreData

// MARK: - Document Model
@objc(DocumentModel)
public class DocumentModel: NSManagedObject, Identifiable {
    
}

// MARK: - Core Data Properties
extension DocumentModel {
    
    @nonobjc public class func fetchRequest() -> NSFetchRequest<DocumentModel> {
        return NSFetchRequest<DocumentModel>(entityName: "Document")
    }
    
    @NSManaged public var id: UUID
    @NSManaged public var title: String
    @NSManaged public var fileName: String
    @NSManaged public var fileURL: URL
    @NSManaged public var fileSize: Int64
    @NSManaged public var mimeType: String
    @NSManaged public var pageCount: Int32
    @NSManaged public var extractedText: String?
    @NSManaged public var detectedLanguage: String?
    @NSManaged public var processingStatus: String
    @NSManaged public var createdAt: Date
    @NSManaged public var updatedAt: Date
    @NSManaged public var tags: String? // JSON array of tags
    @NSManaged public var metadata: Data? // JSON metadata
    
    // Relationships
    @NSManaged public var embeddings: NSSet?
}

// Note: Embedding relationship accessors will be generated by Core Data

// MARK: - Convenience Properties
extension DocumentModel {
    
    var documentType: DocumentType {
        get { DocumentType(rawValue: mimeType) ?? .unknown }
        set { mimeType = newValue.rawValue }
    }
    
    var status: ProcessingStatus {
        get { ProcessingStatus(rawValue: processingStatus) ?? .pending }
        set { processingStatus = newValue.rawValue }
    }
    
    var tagsArray: [String] {
        get {
            guard let tags = tags,
                  let data = tags.data(using: .utf8),
                  let array = try? JSONDecoder().decode([String].self, from: data) else {
                return []
            }
            return array
        }
        set {
            guard let data = try? JSONEncoder().encode(newValue),
                  let jsonString = String(data: data, encoding: .utf8) else {
                tags = nil
                return
            }
            tags = jsonString
        }
    }
    
    var metadataDict: [String: Any] {
        get {
            guard let metadata = metadata,
                  let dict = try? JSONSerialization.jsonObject(with: metadata) as? [String: Any] else {
                return [:]
            }
            return dict
        }
        set {
            guard let data = try? JSONSerialization.data(withJSONObject: newValue) else {
                metadata = nil
                return
            }
            metadata = data
        }
    }
}

// MARK: - Document Type Enum
// Note: DocumentType and ProcessingStatus are now defined in DocumentTypes.swift to avoid circular dependencies 